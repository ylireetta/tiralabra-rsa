# Weekly report 2
I started coding during the first week already, but as mentioned in the previous weekly report, it took me by surprise how many algorithms I was actually going to have to implement. I'm not good at maths, so any of the articles with just mathematical notation and letters in the place of numbers did not help. I had a difficult time understanding in which cases the Miller-Rabin test would fail and when it would pass, but once I figured it out and could return the boolean values with confidence, I was a bit happier with how things were going.

I also had some problems understanding how the extended Euclidean Algorithm worked in practice. After staring at my screen for quite some time and trying to convince myself that I knew what was going on each row, I finally resorted to YouTube and watched the first video that came up. That video ([The Extended Euclidean algorithm](https://www.youtube.com/watch?v=hB34-GSDT3k&pp=ygUcZXh0ZW5kZWQgZXVjbGlkZWFuIGFsZ29yaXRobQ%3D%3D "The Extended Euclidean algorithm")) proved to be an excellent source, and I think I got the hang of it after working through a couple of examples with pen and paper. However, when I try to compute the private key *<d, n>*, I sometimes get negative values. Apparently *d* should never be negative, so I consulted ChatGPT to work out if negative values for *x* from the extended Euclidean algorithm are valid results, why this happens, and how I could modify my code to give me a positive value for *d* while still holding on to the (assumed) integrity of the extended Euclidean algorithm result.

Another problem is the generation of primes. It sort of works, but if I don't give an upper limit for the random number that will be tested for primality, the process takes forever. At the moment I have set the prime candidates to be generated within a specific range, but I need to come up with a way to generate larger primes so that the key generation is a bit more convincing. If there are any tips as to how I should approach this, I would be interested to know.

This has been a week of pain for the most part. I managed to get JUnit and JaCoCo to work, but the next day everything broke down when I added a dependency so that I could use ToStringBuilder. I spent three hours trying to figure out what on earth was going on, and since I am not very familiar with Maven's dependency management, it was a method of trial and error. I finally got the tests working again, but then I ran into trouble with classpaths. I am getting a bit tired of fighting with somewhat irrelevant things, so I just added a note to the project README to remind myself how I can actually run the program without errors. I ended up using the exec-maven-plugin to make the process simpler, but I'm not sure if I like that, either.

Overall, I'm not very happy with how I'm progressing at the moment. The code is far from optimized, there are several things that I cannot be sure work correctly, and some things haven't been implemented yet. I have to put more effort into testing the code and come up with a way to generate some data I know to be correct, and compare the result of my algorithm to that. For example, I know that testing the extended Euclidean algorithm is not really that difficult, but I don't know which values I should test against. I will definitely put testing and improving the effectiveness of my code higher on the priority list in the coming weeks. I copied the checkstyle configuration from one of my earlier projects, and that needs to be reviewed and the errors need to be fixed. It's a great motivator that I set up the project build to fail if there are checkstyle errors present, so I certainly won't forget about it!